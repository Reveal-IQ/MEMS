(self["webpackChunkmems_client"]=self["webpackChunkmems_client"]||[]).push([[5278,1028],{2914:function(e,t,n){var r=n(7293),i=n(9114);e.exports=!r((function(){var e=Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",i(1,7)),7!==e.stack)}))},2104:function(e,t,n){var r=n(4374),i=Function.prototype,o=i.apply,s=i.call;e.exports="object"==typeof Reflect&&Reflect.apply||(r?s.bind(o):function(){return s.apply(o,arguments)})},8340:function(e,t,n){var r=n(111),i=n(8880);e.exports=function(e,t){r(t)&&"cause"in t&&i(e,"cause",t.cause)}},2626:function(e,t,n){var r=n(3070).f;e.exports=function(e,t,n){n in e||r(e,n,{configurable:!0,get:function(){return t[n]},set:function(e){t[n]=e}})}},9191:function(e,t,n){"use strict";var r=n(5005),i=n(2597),o=n(8880),s=n(7976),u=n(7674),f=n(9920),l=n(2626),a=n(9587),c=n(6277),h=n(8340),g=n(7741),d=n(2914),p=n(9781),y=n(1913);e.exports=function(e,t,n,b){var m="stackTraceLimit",w=b?2:1,S=e.split("."),B=S[S.length-1],N=r.apply(null,S);if(N){var O=N.prototype;if(!y&&i(O,"cause")&&delete O.cause,!n)return N;var x=r("Error"),_=t((function(e,t){var n=c(b?t:e,void 0),r=b?new N(e):new N;return void 0!==n&&o(r,"message",n),d&&o(r,"stack",g(r.stack,2)),this&&s(O,this)&&a(r,this,_),arguments.length>w&&h(r,arguments[w]),r}));if(_.prototype=O,"Error"!==B?u?u(_,x):f(_,x,{name:!0}):p&&m in N&&(l(_,N,m),l(_,N,"prepareStackTrace")),f(_,N),!y)try{O.name!==B&&o(O,"name",B),O.constructor=_}catch($){}return _}}},1703:function(e,t,n){var r=n(2109),i=n(7854),o=n(2104),s=n(9191),u="WebAssembly",f=i[u],l=7!==Error("e",{cause:7}).cause,a=function(e,t){var n={};n[e]=s(e,t,l),r({global:!0,forced:l},n)},c=function(e,t){if(f&&f[e]){var n={};n[e]=s(u+"."+e,t,l),r({target:u,stat:!0,forced:l},n)}};a("Error",(function(e){return function(t){return o(e,this,arguments)}})),a("EvalError",(function(e){return function(t){return o(e,this,arguments)}})),a("RangeError",(function(e){return function(t){return o(e,this,arguments)}})),a("ReferenceError",(function(e){return function(t){return o(e,this,arguments)}})),a("SyntaxError",(function(e){return function(t){return o(e,this,arguments)}})),a("TypeError",(function(e){return function(t){return o(e,this,arguments)}})),a("URIError",(function(e){return function(t){return o(e,this,arguments)}})),c("CompileError",(function(e){return function(t){return o(e,this,arguments)}})),c("LinkError",(function(e){return function(t){return o(e,this,arguments)}})),c("RuntimeError",(function(e){return function(t){return o(e,this,arguments)}}))},4200:function(e,t,n){"use strict";n.a(e,(async function(e,r){try{n.d(t,{F2:function(){return l},G$:function(){return u},o$:function(){return f},sr:function(){return a},tf:function(){return c}});n(1703);var i=n(9608),o=e([i]);i=(o.then?(await o)():o)[0];class s{constructor(e,t){this._name=e,this._record={};const n=this.getSchema();s._validateSchema(n),this._record=s._fieldToBsonType(this.getName(),t,n)}getName(){return this._name}getRecord(){return this._record}serialize(){return Array.from(i.s_.serialize(this._record))}getSchema(){throw new Error("Cannot instantiate Record instance. Child classes should implement getSchema()")}static _validateSchema(e){if("object"!==typeof e)throw new Error(`Schema field should be an object: ${JSON.stringify(e)}`);if(void 0==e.type||null==e.type)throw new Error(`Schema field object should have 'type' key: ${JSON.stringify(e)}`);if(!Object.values(i.cl).includes(e.type))throw new Error(`Schema 'type' value is not a BSONType: ${JSON.stringify(e)}`);if(e.type==i.cl.array){if(void 0==e.items||null==e.items)throw new Error(`Schema array field should have 'items' key: ${JSON.stringify(e)}`);this._validateSchema(e.items)}else if(e.type==i.cl.object){if(void 0==e.fields||null==e.fields)throw new Error(`Schema array field should have 'fields' key: ${JSON.stringify(e)}`);Object.keys(e.fields).forEach((t=>this._validateSchema(e.fields[t])))}}static _fieldToBsonType(e,t,n){switch(n.type){case i.cl.string:return"string"==typeof t?t:t.toString();case i.cl.objectId:return new i.Zw(t);case i.cl.date:return new Date(t);case i.cl.timestamp:return new i.hQ(t);case i.cl.bool:return 1==t;case i.cl.int:return new i.Vq(t);case i.cl.long:return new i.dK(t);case i.cl.double:return new i.bh(t);case i.cl.array:let r=t.filter((e=>void 0!==e||null!==e)).map((t=>s._fieldToBsonType(e,t,n.items)));return Array.isArray(r)?r:[];case i.cl.object:const o=Object.keys(t).reduce(((r,i)=>{if(void 0!==t[i]&&null!==t[i]){if(i in n.fields)return r[i]=s._fieldToBsonType(i,t[i],n.fields[i]),r;console.error(`Unsupported field type for Record[${this._name}] field[${e}][${i}] : ${n.type}`)}return r}),{});return"object"===typeof o?o:void 0;default:console.error(`Unsupported field type for Record[${this._name}] field[${e}] : ${n.type}`)}}}class u extends s{constructor(e){super("Asset",e)}getSchema(){return{type:i.cl.object,fields:{assetCode:{type:i.cl.string},description:{type:i.cl.string},serialNumber:{type:i.cl.string},parentAssetID:{type:i.cl.objectId},modelID:{type:i.cl.objectId},manufacturerID:{type:i.cl.objectId},manufactureDate:{type:i.cl.date},facilityID:{type:i.cl.objectId},departmentID:{type:i.cl.objectId},locationName:{type:i.cl.string},supportTeam:{type:i.cl.string},vendorID:{type:i.cl.objectId},status:{type:i.cl.string},purchaseOrderID:{type:i.cl.objectId},acceptanceDate:{type:i.cl.date},purchaseCost:{type:i.cl.double},comment:{type:i.cl.string}}}}}class f extends s{constructor(e){super("Facility",e)}getSchema(){return{type:i.cl.object,fields:{facilityName:{type:i.cl.string},address_1:{type:i.cl.string},address_2:{type:i.cl.string},city:{type:i.cl.string},area:{type:i.cl.string},areaCode:{type:i.cl.string},country:{type:i.cl.string}}}}}class l extends s{constructor(e){super("Manufacturer",e)}getSchema(){return{type:i.cl.object,fields:{manufacturerName:{type:i.cl.string}}}}}class a extends s{constructor(e){super("Model",e)}getSchema(){return{type:i.cl.object,fields:{manufacturerID:{type:i.cl.objectId},contactID:{type:i.cl.objectId},modelName:{type:i.cl.string},commonName:{type:i.cl.string},UMDNSCode:{type:i.cl.string}}}}}class c extends s{constructor(e){super("Vendor",e)}getSchema(){return{type:i.cl.object,fields:{vendorName:{type:i.cl.string},country:{type:i.cl.string},area:{type:i.cl.string},city:{type:i.cl.string},address_1:{type:i.cl.string},address_2:{type:i.cl.string},areaCode:{type:i.cl.string},contactInfo:{type:i.cl.array,items:{type:i.cl.object,fields:{number:{type:i.cl.string},name:{type:i.cl.string},email:{type:i.cl.string},type:{type:i.cl.string}}}},manufacturerList:{type:i.cl.array,items:{type:i.cl.object,fields:{manufacturer:{type:i.cl.objectId}}}}}}}}r()}catch(s){r(s)}}))},1948:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return a}});var r=n(6252),i=n(3577),o=n(2262);const s={class:"fsXs"};var u={props:{BtnName:{type:String,default:"Button Name"},class:{type:String,default:""},showLoader:{type:Boolean,default:!1},backgroundColor:{type:String,default:"#586974"},icon:null},emits:[""],setup(e,{emit:t}){const n=e;let u=n.icon;return(t,n)=>{const f=(0,r.up)("font-awesome-icon");return(0,r.wg)(),(0,r.iD)("button",{type:"button",class:(0,i.C_)(["btn buttonBackground d-inline-flex align-items-center fs-6 rounded",e.class]),style:(0,i.j5)("--color:"+e.backgroundColor)},[(0,r.Wm)(f,{icon:(0,o.SU)(u),size:"1x",class:"me-2"},null,8,["icon"]),(0,r._)("span",s,(0,i.zw)(e.BtnName),1),(0,r.WI)(t.$slots,"default")],6)}}},f=n(3744);const l=(0,f.Z)(u,[["__scopeId","data-v-1a26e9bf"]]);var a=l},1028:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return a}});var r=n(6252),i=n(3577);const o=["for"],s={class:"input-group mb-3"},u=["placeholder","id","type","value"];var f={props:{label:{type:String,default:"label"},placeholder:{type:String,default:""},id:{type:String,default:""},type:{type:String,default:"text"},modelValue:{type:[String,Number],default:""}},setup(e){return(t,n)=>((0,r.wg)(),(0,r.iD)(r.HY,null,[e.label?((0,r.wg)(),(0,r.iD)("label",{key:0,for:e.id,class:"form-label"},(0,i.zw)(e.label),9,o)):(0,r.kq)("",!0),(0,r._)("div",s,[(0,r._)("input",(0,r.dG)(t.$attrs,{placeholder:e.placeholder,id:e.id,type:e.type,class:"form-control",value:e.modelValue,onInput:n[0]||(n[0]=e=>t.$emit("update:modelValue",e.target.value))}),null,16,u)])],64))}};const l=f;var a=l},3432:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return a}});var r=n(6252),i=n(3577);const o={class:"section p-4 rounded shadow-sm"},s={class:"pb-3 fsXl section-title"};var u={props:{sectionTitle:{type:String,default:"Section Title"}},setup(e){return(t,n)=>((0,r.wg)(),(0,r.iD)("section",o,[(0,r._)("h5",s,(0,i.zw)(e.sectionTitle),1),(0,r.WI)(t.$slots,"default")]))}},f=n(3744);const l=(0,f.Z)(u,[["__scopeId","data-v-cfc2dae0"]]);var a=l},9608:function(e,t,n){"use strict";n.a(e,(async function(e,r){try{n.d(t,{Vq:function(){return Ce},Zw:function(){return Ge},bh:function(){return qe},cl:function(){return k},dK:function(){return Ne},hQ:function(){return it},s_:function(){return o}});var i=n(8764)["Buffer"];function u(e){return["[object ArrayBuffer]","[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(e))}function f(e){return"[object Uint8Array]"===Object.prototype.toString.call(e)}function l(e){return"[object RegExp]"===Object.prototype.toString.call(e)}function a(e){return"[object Map]"===Object.prototype.toString.call(e)}function c(e){return"[object Date]"===Object.prototype.toString.call(e)}const h=6,g=2147483647,d=-2147483648,p=Math.pow(2,63)-1,y=-Math.pow(2,63),b=Math.pow(2,53),m=-Math.pow(2,53),w=1,S=2,B=3,N=4,O=5,x=6,_=7,$=8,E=9,U=10,v=11,I=12,T=13,L=14,j=15,A=16,D=17,R=18,F=19,M=255,J=127,V=0,z=4,k=Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127});class H extends Error{get bsonError(){return!0}get name(){return"BSONError"}constructor(e){super(e)}static isBSONError(e){return null!=e&&"object"===typeof e&&"bsonError"in e&&!0===e.bsonError&&"name"in e&&"message"in e&&"stack"in e}}class q extends H{get name(){return"BSONVersionError"}constructor(){super(`Unsupported BSON version, bson types must be from bson ${h}.0 or later`)}}class C extends H{get name(){return"BSONRuntimeError"}constructor(e){super(e)}}function Z(e){return P.fromNumberArray(Array.from({length:e},(()=>Math.floor(256*Math.random()))))}const Y=await(async()=>{try{return(await Promise.resolve().then(n.t.bind(n,5835,19))).randomBytes}catch{return Z}})(),P={toLocalBufferType(e){if(i.isBuffer(e))return e;if(ArrayBuffer.isView(e))return i.from(e.buffer,e.byteOffset,e.byteLength);const t=e?.[Symbol.toStringTag]??Object.prototype.toString.call(e);if("ArrayBuffer"===t||"SharedArrayBuffer"===t||"[object ArrayBuffer]"===t||"[object SharedArrayBuffer]"===t)return i.from(e);throw new H(`Cannot create Buffer from ${String(e)}`)},allocate(e){return i.alloc(e)},equals(e,t){return P.toLocalBufferType(e).equals(t)},fromNumberArray(e){return i.from(e)},fromBase64(e){return i.from(e,"base64")},toBase64(e){return P.toLocalBufferType(e).toString("base64")},fromISO88591(e){return i.from(e,"binary")},toISO88591(e){return P.toLocalBufferType(e).toString("binary")},fromHex(e){return i.from(e,"hex")},toHex(e){return P.toLocalBufferType(e).toString("hex")},fromUTF8(e){return i.from(e,"utf8")},toUTF8(e,t,n){return P.toLocalBufferType(e).toString("utf8",t,n)},utf8ByteLength(e){return i.byteLength(e,"utf8")},encodeUTF8Into(e,t,n){return P.toLocalBufferType(e).write(t,n,void 0,"utf8")},randomBytes:Y};function K(){const{navigator:e}=globalThis;return"object"===typeof e&&"ReactNative"===e.product}function W(e){if(e<0)throw new RangeError(`The argument 'byteLength' is invalid. Received ${e}`);return Q.fromNumberArray(Array.from({length:e},(()=>Math.floor(256*Math.random()))))}const G=(()=>{const{crypto:e}=globalThis;if(null!=e&&"function"===typeof e.getRandomValues)return t=>e.getRandomValues(Q.allocate(t));if(K()){const{console:e}=globalThis;e?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return W})(),X=/(\d|[a-f])/i,Q={toLocalBufferType(e){const t=e?.[Symbol.toStringTag]??Object.prototype.toString.call(e);if("Uint8Array"===t)return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength));if("ArrayBuffer"===t||"SharedArrayBuffer"===t||"[object ArrayBuffer]"===t||"[object SharedArrayBuffer]"===t)return new Uint8Array(e);throw new H(`Cannot make a Uint8Array from ${String(e)}`)},allocate(e){if("number"!==typeof e)throw new TypeError(`The "size" argument must be of type number. Received ${String(e)}`);return new Uint8Array(e)},equals(e,t){if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0},fromNumberArray(e){return Uint8Array.from(e)},fromBase64(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))},toBase64(e){return btoa(Q.toISO88591(e))},fromISO88591(e){return Uint8Array.from(e,(e=>255&e.charCodeAt(0)))},toISO88591(e){return Array.from(Uint16Array.from(e),(e=>String.fromCharCode(e))).join("")},fromHex(e){const t=e.length%2===0?e:e.slice(0,e.length-1),n=[];for(let r=0;r<t.length;r+=2){const e=t[r],i=t[r+1];if(!X.test(e))break;if(!X.test(i))break;const o=Number.parseInt(`${e}${i}`,16);n.push(o)}return Uint8Array.from(n)},toHex(e){return Array.from(e,(e=>e.toString(16).padStart(2,"0"))).join("")},fromUTF8(e){return(new TextEncoder).encode(e)},toUTF8(e,t,n){return new TextDecoder("utf8",{fatal:!1}).decode(e.slice(t,n))},utf8ByteLength(e){return Q.fromUTF8(e).byteLength},encodeUTF8Into(e,t,n){const r=Q.fromUTF8(t);return e.set(r,n),r.byteLength},randomBytes:G},ee="function"===typeof i&&!0!==i.prototype?._isBuffer,te=ee?P:Q;class ne extends DataView{static fromUint8Array(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}}class re{get[Symbol.for("@@mdb.bson.version")](){return h}}class ie extends re{get _bsontype(){return"Binary"}constructor(e,t){if(super(),null!=e&&"string"===typeof e&&!ArrayBuffer.isView(e)&&!u(e)&&!Array.isArray(e))throw new H("Binary can only be constructed from Uint8Array or number[]");this.sub_type=t??ie.BSON_BINARY_SUBTYPE_DEFAULT,null==e?(this.buffer=te.allocate(ie.BUFFER_SIZE),this.position=0):(this.buffer=Array.isArray(e)?te.fromNumberArray(e):te.toLocalBufferType(e),this.position=this.buffer.byteLength)}put(e){if("string"===typeof e&&1!==e.length)throw new H("only accepts single character String");if("number"!==typeof e&&1!==e.length)throw new H("only accepts single character Uint8Array or Array");let t;if(t="string"===typeof e?e.charCodeAt(0):"number"===typeof e?e:e[0],t<0||t>255)throw new H("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.byteLength>this.position)this.buffer[this.position++]=t;else{const e=te.allocate(ie.BUFFER_SIZE+this.buffer.length);e.set(this.buffer,0),this.buffer=e,this.buffer[this.position++]=t}}write(e,t){if(t="number"===typeof t?t:this.position,this.buffer.byteLength<t+e.length){const t=te.allocate(this.buffer.byteLength+e.length);t.set(this.buffer,0),this.buffer=t}if(ArrayBuffer.isView(e))this.buffer.set(te.toLocalBufferType(e),t),this.position=t+e.byteLength>this.position?t+e.length:this.position;else if("string"===typeof e)throw new H("input cannot be string")}read(e,t){return t=t&&t>0?t:this.position,this.buffer.slice(e,e+t)}value(){return this.buffer.length===this.position?this.buffer:this.buffer.subarray(0,this.position)}length(){return this.position}toJSON(){return te.toBase64(this.buffer)}toString(e){return"hex"===e?te.toHex(this.buffer):"base64"===e?te.toBase64(this.buffer):te.toUTF8(this.buffer,0,this.buffer.byteLength)}toExtendedJSON(e){e=e||{};const t=te.toBase64(this.buffer),n=Number(this.sub_type).toString(16);return e.legacy?{$binary:t,$type:1===n.length?"0"+n:n}:{$binary:{base64:t,subType:1===n.length?"0"+n:n}}}toUUID(){if(this.sub_type===ie.SUBTYPE_UUID)return new fe(this.buffer.slice(0,this.position));throw new H(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${ie.SUBTYPE_UUID}" is currently supported.`)}static createFromHexString(e,t){return new ie(te.fromHex(e),t)}static createFromBase64(e,t){return new ie(te.fromBase64(e),t)}static fromExtendedJSON(e,t){let n,r;if(t=t||{},"$binary"in e?t.legacy&&"string"===typeof e.$binary&&"$type"in e?(r=e.$type?parseInt(e.$type,16):0,n=te.fromBase64(e.$binary)):"string"!==typeof e.$binary&&(r=e.$binary.subType?parseInt(e.$binary.subType,16):0,n=te.fromBase64(e.$binary.base64)):"$uuid"in e&&(r=4,n=fe.bytesFromString(e.$uuid)),!n)throw new H(`Unexpected Binary Extended JSON format ${JSON.stringify(e)}`);return r===z?new fe(n):new ie(n,r)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const e=te.toBase64(this.buffer.subarray(0,this.position));return`Binary.createFromBase64("${e}", ${this.sub_type})`}}ie.BSON_BINARY_SUBTYPE_DEFAULT=0,ie.BUFFER_SIZE=256,ie.SUBTYPE_DEFAULT=0,ie.SUBTYPE_FUNCTION=1,ie.SUBTYPE_BYTE_ARRAY=2,ie.SUBTYPE_UUID_OLD=3,ie.SUBTYPE_UUID=4,ie.SUBTYPE_MD5=5,ie.SUBTYPE_ENCRYPTED=6,ie.SUBTYPE_COLUMN=7,ie.SUBTYPE_USER_DEFINED=128;const oe=16,se=/^[0-9A-F]{32}$/i,ue=/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;class fe extends ie{constructor(e){let t;if(null==e)t=fe.generate();else if(e instanceof fe)t=te.toLocalBufferType(new Uint8Array(e.buffer));else if(ArrayBuffer.isView(e)&&e.byteLength===oe)t=te.toLocalBufferType(e);else{if("string"!==typeof e)throw new H("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");t=fe.bytesFromString(e)}super(t,z)}get id(){return this.buffer}set id(e){this.buffer=e}toHexString(e=!0){return e?[te.toHex(this.buffer.subarray(0,4)),te.toHex(this.buffer.subarray(4,6)),te.toHex(this.buffer.subarray(6,8)),te.toHex(this.buffer.subarray(8,10)),te.toHex(this.buffer.subarray(10,16))].join("-"):te.toHex(this.buffer)}toString(e){return"hex"===e?te.toHex(this.id):"base64"===e?te.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}equals(e){if(!e)return!1;if(e instanceof fe)return te.equals(e.id,this.id);try{return te.equals(new fe(e).id,this.id)}catch{return!1}}toBinary(){return new ie(this.id,ie.SUBTYPE_UUID)}static generate(){const e=te.randomBytes(oe);return e[6]=15&e[6]|64,e[8]=63&e[8]|128,e}static isValid(e){return!!e&&("string"===typeof e?fe.isValidUUIDString(e):f(e)?e.byteLength===oe:"Binary"===e._bsontype&&e.sub_type===this.SUBTYPE_UUID&&16===e.buffer.byteLength)}static createFromHexString(e){const t=fe.bytesFromString(e);return new fe(t)}static createFromBase64(e){return new fe(te.fromBase64(e))}static bytesFromString(e){if(!fe.isValidUUIDString(e))throw new H("UUID string representation must be 32 hex digits or canonical hyphenated representation");return te.fromHex(e.replace(/-/g,""))}static isValidUUIDString(e){return se.test(e)||ue.test(e)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new UUID("${this.toHexString()}")`}}class le extends re{get _bsontype(){return"Code"}constructor(e,t){super(),this.code=e.toString(),this.scope=t??null}toJSON(){return null!=this.scope?{code:this.code,scope:this.scope}:{code:this.code}}toExtendedJSON(){return this.scope?{$code:this.code,$scope:this.scope}:{$code:this.code}}static fromExtendedJSON(e){return new le(e.$code,e.$scope)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const e=this.toJSON();return`new Code(${JSON.stringify(String(e.code))}${null!=e.scope?`, ${JSON.stringify(e.scope)}`:""})`}}function ae(e){return null!=e&&"object"===typeof e&&"$id"in e&&null!=e.$id&&"$ref"in e&&"string"===typeof e.$ref&&(!("$db"in e)||"$db"in e&&"string"===typeof e.$db)}class ce extends re{get _bsontype(){return"DBRef"}constructor(e,t,n,r){super();const i=e.split(".");2===i.length&&(n=i.shift(),e=i.shift()),this.collection=e,this.oid=t,this.db=n,this.fields=r||{}}get namespace(){return this.collection}set namespace(e){this.collection=e}toJSON(){const e=Object.assign({$ref:this.collection,$id:this.oid},this.fields);return null!=this.db&&(e.$db=this.db),e}toExtendedJSON(e){e=e||{};let t={$ref:this.collection,$id:this.oid};return e.legacy||(this.db&&(t.$db=this.db),t=Object.assign(t,this.fields)),t}static fromExtendedJSON(e){const t=Object.assign({},e);return delete t.$ref,delete t.$id,delete t.$db,new ce(e.$ref,e.$id,e.$db,t)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const e=void 0===this.oid||void 0===this.oid.toString?this.oid:this.oid.toString();return`new DBRef("${this.namespace}", new ObjectId("${String(e)}")${this.db?`, "${this.db}"`:""})`}}let he;try{he=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}const ge=65536,de=1<<24,pe=ge*ge,ye=pe*pe,be=ye/2,me={},we={},Se=20,Be=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;class Ne extends re{get _bsontype(){return"Long"}get __isLong__(){return!0}constructor(e=0,t,n){super(),"bigint"===typeof e?Object.assign(this,Ne.fromBigInt(e,!!t)):"string"===typeof e?Object.assign(this,Ne.fromString(e,!!t)):(this.low=0|e,this.high=0|t,this.unsigned=!!n)}static fromBits(e,t,n){return new Ne(e,t,n)}static fromInt(e,t){let n,r,i;return t?(e>>>=0,(i=0<=e&&e<256)&&(r=we[e],r)?r:(n=Ne.fromBits(e,(0|e)<0?-1:0,!0),i&&(we[e]=n),n)):(e|=0,(i=-128<=e&&e<128)&&(r=me[e],r)?r:(n=Ne.fromBits(e,e<0?-1:0,!1),i&&(me[e]=n),n))}static fromNumber(e,t){if(isNaN(e))return t?Ne.UZERO:Ne.ZERO;if(t){if(e<0)return Ne.UZERO;if(e>=ye)return Ne.MAX_UNSIGNED_VALUE}else{if(e<=-be)return Ne.MIN_VALUE;if(e+1>=be)return Ne.MAX_VALUE}return e<0?Ne.fromNumber(-e,t).neg():Ne.fromBits(e%pe|0,e/pe|0,t)}static fromBigInt(e,t){return Ne.fromString(e.toString(),t)}static fromString(e,t,n){if(0===e.length)throw new H("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return Ne.ZERO;if("number"===typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw new H("radix");let r;if((r=e.indexOf("-"))>0)throw new H("interior hyphen");if(0===r)return Ne.fromString(e.substring(1),t,n).neg();const i=Ne.fromNumber(Math.pow(n,8));let o=Ne.ZERO;for(let s=0;s<e.length;s+=8){const t=Math.min(8,e.length-s),r=parseInt(e.substring(s,s+t),n);if(t<8){const e=Ne.fromNumber(Math.pow(n,t));o=o.mul(e).add(Ne.fromNumber(r))}else o=o.mul(i),o=o.add(Ne.fromNumber(r))}return o.unsigned=t,o}static fromBytes(e,t,n){return n?Ne.fromBytesLE(e,t):Ne.fromBytesBE(e,t)}static fromBytesLE(e,t){return new Ne(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)}static fromBytesBE(e,t){return new Ne(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}static isLong(e){return null!=e&&"object"===typeof e&&"__isLong__"in e&&!0===e.__isLong__}static fromValue(e,t){return"number"===typeof e?Ne.fromNumber(e,t):"string"===typeof e?Ne.fromString(e,t):Ne.fromBits(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}add(e){Ne.isLong(e)||(e=Ne.fromValue(e));const t=this.high>>>16,n=65535&this.high,r=this.low>>>16,i=65535&this.low,o=e.high>>>16,s=65535&e.high,u=e.low>>>16,f=65535&e.low;let l=0,a=0,c=0,h=0;return h+=i+f,c+=h>>>16,h&=65535,c+=r+u,a+=c>>>16,c&=65535,a+=n+s,l+=a>>>16,a&=65535,l+=t+o,l&=65535,Ne.fromBits(c<<16|h,l<<16|a,this.unsigned)}and(e){return Ne.isLong(e)||(e=Ne.fromValue(e)),Ne.fromBits(this.low&e.low,this.high&e.high,this.unsigned)}compare(e){if(Ne.isLong(e)||(e=Ne.fromValue(e)),this.eq(e))return 0;const t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1}comp(e){return this.compare(e)}divide(e){if(Ne.isLong(e)||(e=Ne.fromValue(e)),e.isZero())throw new H("division by zero");if(he){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;const t=(this.unsigned?he.div_u:he.div_s)(this.low,this.high,e.low,e.high);return Ne.fromBits(t,he.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ne.UZERO:Ne.ZERO;let t,n,r;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Ne.UZERO;if(e.gt(this.shru(1)))return Ne.UONE;r=Ne.UZERO}else{if(this.eq(Ne.MIN_VALUE)){if(e.eq(Ne.ONE)||e.eq(Ne.NEG_ONE))return Ne.MIN_VALUE;if(e.eq(Ne.MIN_VALUE))return Ne.ONE;{const i=this.shr(1);return t=i.div(e).shl(1),t.eq(Ne.ZERO)?e.isNegative()?Ne.ONE:Ne.NEG_ONE:(n=this.sub(e.mul(t)),r=t.add(n.div(e)),r)}}if(e.eq(Ne.MIN_VALUE))return this.unsigned?Ne.UZERO:Ne.ZERO;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();r=Ne.ZERO}n=this;while(n.gte(e)){t=Math.max(1,Math.floor(n.toNumber()/e.toNumber()));const i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:Math.pow(2,i-48);let s=Ne.fromNumber(t),u=s.mul(e);while(u.isNegative()||u.gt(n))t-=o,s=Ne.fromNumber(t,this.unsigned),u=s.mul(e);s.isZero()&&(s=Ne.ONE),r=r.add(s),n=n.sub(u)}return r}div(e){return this.divide(e)}equals(e){return Ne.isLong(e)||(e=Ne.fromValue(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)}eq(e){return this.equals(e)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){if(this.isNegative())return this.eq(Ne.MIN_VALUE)?64:this.neg().getNumBitsAbs();const e=0!==this.high?this.high:this.low;let t;for(t=31;t>0;t--)if(0!==(e&1<<t))break;return 0!==this.high?t+33:t+1}greaterThan(e){return this.comp(e)>0}gt(e){return this.greaterThan(e)}greaterThanOrEqual(e){return this.comp(e)>=0}gte(e){return this.greaterThanOrEqual(e)}ge(e){return this.greaterThanOrEqual(e)}isEven(){return 0===(1&this.low)}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return 1===(1&this.low)}isPositive(){return this.unsigned||this.high>=0}isZero(){return 0===this.high&&0===this.low}lessThan(e){return this.comp(e)<0}lt(e){return this.lessThan(e)}lessThanOrEqual(e){return this.comp(e)<=0}lte(e){return this.lessThanOrEqual(e)}modulo(e){if(Ne.isLong(e)||(e=Ne.fromValue(e)),he){const t=(this.unsigned?he.rem_u:he.rem_s)(this.low,this.high,e.low,e.high);return Ne.fromBits(t,he.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))}mod(e){return this.modulo(e)}rem(e){return this.modulo(e)}multiply(e){if(this.isZero())return Ne.ZERO;if(Ne.isLong(e)||(e=Ne.fromValue(e)),he){const t=he.mul(this.low,this.high,e.low,e.high);return Ne.fromBits(t,he.get_high(),this.unsigned)}if(e.isZero())return Ne.ZERO;if(this.eq(Ne.MIN_VALUE))return e.isOdd()?Ne.MIN_VALUE:Ne.ZERO;if(e.eq(Ne.MIN_VALUE))return this.isOdd()?Ne.MIN_VALUE:Ne.ZERO;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Ne.TWO_PWR_24)&&e.lt(Ne.TWO_PWR_24))return Ne.fromNumber(this.toNumber()*e.toNumber(),this.unsigned);const t=this.high>>>16,n=65535&this.high,r=this.low>>>16,i=65535&this.low,o=e.high>>>16,s=65535&e.high,u=e.low>>>16,f=65535&e.low;let l=0,a=0,c=0,h=0;return h+=i*f,c+=h>>>16,h&=65535,c+=r*f,a+=c>>>16,c&=65535,c+=i*u,a+=c>>>16,c&=65535,a+=n*f,l+=a>>>16,a&=65535,a+=r*u,l+=a>>>16,a&=65535,a+=i*s,l+=a>>>16,a&=65535,l+=t*f+n*u+r*s+i*o,l&=65535,Ne.fromBits(c<<16|h,l<<16|a,this.unsigned)}mul(e){return this.multiply(e)}negate(){return!this.unsigned&&this.eq(Ne.MIN_VALUE)?Ne.MIN_VALUE:this.not().add(Ne.ONE)}neg(){return this.negate()}not(){return Ne.fromBits(~this.low,~this.high,this.unsigned)}notEquals(e){return!this.equals(e)}neq(e){return this.notEquals(e)}ne(e){return this.notEquals(e)}or(e){return Ne.isLong(e)||(e=Ne.fromValue(e)),Ne.fromBits(this.low|e.low,this.high|e.high,this.unsigned)}shiftLeft(e){return Ne.isLong(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?Ne.fromBits(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ne.fromBits(0,this.low<<e-32,this.unsigned)}shl(e){return this.shiftLeft(e)}shiftRight(e){return Ne.isLong(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?Ne.fromBits(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ne.fromBits(this.high>>e-32,this.high>=0?0:-1,this.unsigned)}shr(e){return this.shiftRight(e)}shiftRightUnsigned(e){if(Ne.isLong(e)&&(e=e.toInt()),e&=63,0===e)return this;{const t=this.high;if(e<32){const n=this.low;return Ne.fromBits(n>>>e|t<<32-e,t>>>e,this.unsigned)}return 32===e?Ne.fromBits(t,0,this.unsigned):Ne.fromBits(t>>>e-32,0,this.unsigned)}}shr_u(e){return this.shiftRightUnsigned(e)}shru(e){return this.shiftRightUnsigned(e)}subtract(e){return Ne.isLong(e)||(e=Ne.fromValue(e)),this.add(e.neg())}sub(e){return this.subtract(e)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){return this.unsigned?(this.high>>>0)*pe+(this.low>>>0):this.high*pe+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(e){return e?this.toBytesLE():this.toBytesBE()}toBytesLE(){const e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]}toBytesBE(){const e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]}toSigned(){return this.unsigned?Ne.fromBits(this.low,this.high,!1):this}toString(e){if(e=e||10,e<2||36<e)throw new H("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Ne.MIN_VALUE)){const t=Ne.fromNumber(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}const t=Ne.fromNumber(Math.pow(e,6),this.unsigned);let n=this,r="";while(1){const i=n.div(t),o=n.sub(i.mul(t)).toInt()>>>0;let s=o.toString(e);if(n=i,n.isZero())return s+r;while(s.length<6)s="0"+s;r=""+s+r}}toUnsigned(){return this.unsigned?this:Ne.fromBits(this.low,this.high,!0)}xor(e){return Ne.isLong(e)||(e=Ne.fromValue(e)),Ne.fromBits(this.low^e.low,this.high^e.high,this.unsigned)}eqz(){return this.isZero()}le(e){return this.lessThanOrEqual(e)}toExtendedJSON(e){return e&&e.relaxed?this.toNumber():{$numberLong:this.toString()}}static fromExtendedJSON(e,t){const{useBigInt64:n=!1,relaxed:r=!0}={...t};if(e.$numberLong.length>Se)throw new H("$numberLong string is too long");if(!Be.test(e.$numberLong))throw new H(`$numberLong string "${e.$numberLong}" is in an invalid format`);if(n){const t=BigInt(e.$numberLong);return BigInt.asIntN(64,t)}const i=Ne.fromString(e.$numberLong);return r?i.toNumber():i}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Long("${this.toString()}"${this.unsigned?", true":""})`}}Ne.TWO_PWR_24=Ne.fromInt(de),Ne.MAX_UNSIGNED_VALUE=Ne.fromBits(-1,-1,!0),Ne.ZERO=Ne.fromInt(0),Ne.UZERO=Ne.fromInt(0,!0),Ne.ONE=Ne.fromInt(1),Ne.UONE=Ne.fromInt(1,!0),Ne.NEG_ONE=Ne.fromInt(-1),Ne.MAX_VALUE=Ne.fromBits(-1,2147483647,!1),Ne.MIN_VALUE=Ne.fromBits(0,-2147483648,!1);const Oe=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/,xe=/^(\+|-)?(Infinity|inf)$/i,_e=/^(\+|-)?NaN$/i,$e=6111,Ee=-6176,Ue=6176,ve=34,Ie=te.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Te=te.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Le=te.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),je=/^([-+])?(\d+)?$/,Ae=31,De=16383,Re=30,Fe=31;function Me(e){return!isNaN(parseInt(e,10))}function Je(e){const t=Ne.fromNumber(1e9);let n=Ne.fromNumber(0);if(!e.parts[0]&&!e.parts[1]&&!e.parts[2]&&!e.parts[3])return{quotient:e,rem:n};for(let r=0;r<=3;r++)n=n.shiftLeft(32),n=n.add(new Ne(e.parts[r],0)),e.parts[r]=n.div(t).low,n=n.modulo(t);return{quotient:e,rem:n}}function Ve(e,t){if(!e&&!t)return{high:Ne.fromNumber(0),low:Ne.fromNumber(0)};const n=e.shiftRightUnsigned(32),r=new Ne(e.getLowBits(),0),i=t.shiftRightUnsigned(32),o=new Ne(t.getLowBits(),0);let s=n.multiply(i),u=n.multiply(o);const f=r.multiply(i);let l=r.multiply(o);return s=s.add(u.shiftRightUnsigned(32)),u=new Ne(u.getLowBits(),0).add(f).add(l.shiftRightUnsigned(32)),s=s.add(u.shiftRightUnsigned(32)),l=u.shiftLeft(32).add(new Ne(l.getLowBits(),0)),{high:s,low:l}}function ze(e,t){const n=e.high>>>0,r=t.high>>>0;if(n<r)return!0;if(n===r){const n=e.low>>>0,r=t.low>>>0;if(n<r)return!0}return!1}function ke(e,t){throw new H(`"${e}" is not a valid Decimal128 string - ${t}`)}class He extends re{get _bsontype(){return"Decimal128"}constructor(e){if(super(),"string"===typeof e)this.bytes=He.fromString(e).bytes;else{if(!f(e))throw new H("Decimal128 must take a Buffer or string");if(16!==e.byteLength)throw new H("Decimal128 must take a Buffer of 16 bytes");this.bytes=e}}static fromString(e){let t=!1,n=!1,r=!1,i=!1,o=0,s=0,u=0,f=0,l=0;const a=[0];let c=0,h=0,g=0,d=0,p=new Ne(0,0),y=new Ne(0,0),b=0,m=0;if(e.length>=7e3)throw new H(e+" not a valid Decimal128 string");const w=e.match(Oe),S=e.match(xe),B=e.match(_e);if(!w&&!S&&!B||0===e.length)throw new H(e+" not a valid Decimal128 string");if(w){const t=w[2],n=w[4],r=w[5],i=w[6];n&&void 0===i&&ke(e,"missing exponent power"),n&&void 0===t&&ke(e,"missing exponent base"),void 0===n&&(r||i)&&ke(e,"missing e before exponent")}if("+"!==e[m]&&"-"!==e[m]||(n=!0,t="-"===e[m++]),!Me(e[m])&&"."!==e[m]){if("i"===e[m]||"I"===e[m])return new He(t?Te:Le);if("N"===e[m])return new He(Ie)}while(Me(e[m])||"."===e[m])"."!==e[m]?(c<ve&&("0"!==e[m]||i)&&(i||(l=s),i=!0,a[h++]=parseInt(e[m],10),c+=1),i&&(u+=1),r&&(f+=1),s+=1,m+=1):(r&&ke(e,"contains multiple periods"),r=!0,m+=1);if(r&&!s)throw new H(e+" not a valid Decimal128 string");if("e"===e[m]||"E"===e[m]){const t=e.substr(++m).match(je);if(!t||!t[2])return new He(Ie);d=parseInt(t[0],10),m+=t[0].length}if(e[m])return new He(Ie);if(c){if(g=c-1,o=u,1!==o)while("0"===e[l+o-1+Number(n)+Number(r)])o-=1}else a[0]=0,u=1,c=1,o=0;d<=f&&f>d+16384?d=Ee:d-=f;while(d>$e){if(g+=1,g>=ve){if(0===o){d=$e;break}ke(e,"overflow")}d-=1}while(d<Ee||c<u){if(0===g){if(0===o){d=Ee;break}ke(e,"exponent underflow")}c<u?("0"!==e[u-1+Number(n)+Number(r)]&&0!==o&&ke(e,"inexact rounding"),u-=1):(0!==a[g]&&ke(e,"inexact rounding"),g-=1),d<$e?d+=1:ke(e,"overflow")}if(g+1<o){r&&(l+=1),n&&(l+=1);const t=parseInt(e[l+g+1],10);0!==t&&ke(e,"inexact rounding")}if(p=Ne.fromNumber(0),y=Ne.fromNumber(0),0===o)p=Ne.fromNumber(0),y=Ne.fromNumber(0);else if(g<17){let e=0;for(y=Ne.fromNumber(a[e++]),p=new Ne(0,0);e<=g;e++)y=y.multiply(Ne.fromNumber(10)),y=y.add(Ne.fromNumber(a[e]))}else{let e=0;for(p=Ne.fromNumber(a[e++]);e<=g-17;e++)p=p.multiply(Ne.fromNumber(10)),p=p.add(Ne.fromNumber(a[e]));for(y=Ne.fromNumber(a[e++]);e<=g;e++)y=y.multiply(Ne.fromNumber(10)),y=y.add(Ne.fromNumber(a[e]))}const N=Ve(p,Ne.fromString("100000000000000000"));N.low=N.low.add(y),ze(N.low,y)&&(N.high=N.high.add(Ne.fromNumber(1))),b=d+Ue;const O={low:Ne.fromNumber(0),high:Ne.fromNumber(0)};N.high.shiftRightUnsigned(49).and(Ne.fromNumber(1)).equals(Ne.fromNumber(1))?(O.high=O.high.or(Ne.fromNumber(3).shiftLeft(61)),O.high=O.high.or(Ne.fromNumber(b).and(Ne.fromNumber(16383).shiftLeft(47))),O.high=O.high.or(N.high.and(Ne.fromNumber(0x7fffffffffff)))):(O.high=O.high.or(Ne.fromNumber(16383&b).shiftLeft(49)),O.high=O.high.or(N.high.and(Ne.fromNumber(562949953421311)))),O.low=N.low,t&&(O.high=O.high.or(Ne.fromString("9223372036854775808")));const x=te.allocate(16);return m=0,x[m++]=255&O.low.low,x[m++]=O.low.low>>8&255,x[m++]=O.low.low>>16&255,x[m++]=O.low.low>>24&255,x[m++]=255&O.low.high,x[m++]=O.low.high>>8&255,x[m++]=O.low.high>>16&255,x[m++]=O.low.high>>24&255,x[m++]=255&O.high.low,x[m++]=O.high.low>>8&255,x[m++]=O.high.low>>16&255,x[m++]=O.high.low>>24&255,x[m++]=255&O.high.high,x[m++]=O.high.high>>8&255,x[m++]=O.high.high>>16&255,x[m++]=O.high.high>>24&255,new He(x)}toString(){let e,t=0;const n=new Array(36);for(let w=0;w<n.length;w++)n[w]=0;let r,i,o,s=0,u=!1,f={parts:[0,0,0,0]};const l=[];s=0;const a=this.bytes,c=a[s++]|a[s++]<<8|a[s++]<<16|a[s++]<<24,h=a[s++]|a[s++]<<8|a[s++]<<16|a[s++]<<24,g=a[s++]|a[s++]<<8|a[s++]<<16|a[s++]<<24,d=a[s++]|a[s++]<<8|a[s++]<<16|a[s++]<<24;s=0;const p={low:new Ne(c,h),high:new Ne(g,d)};p.high.lessThan(Ne.ZERO)&&l.push("-");const y=d>>26&Ae;if(y>>3===3){if(y===Re)return l.join("")+"Infinity";if(y===Fe)return"NaN";e=d>>15&De,r=8+(d>>14&1)}else r=d>>14&7,e=d>>17&De;const b=e-Ue;if(f.parts[0]=(16383&d)+((15&r)<<14),f.parts[1]=g,f.parts[2]=h,f.parts[3]=c,0===f.parts[0]&&0===f.parts[1]&&0===f.parts[2]&&0===f.parts[3])u=!0;else for(o=3;o>=0;o--){let e=0;const t=Je(f);if(f=t.quotient,e=t.rem.low,e)for(i=8;i>=0;i--)n[9*o+i]=e%10,e=Math.floor(e/10)}if(u)t=1,n[s]=0;else{t=36;while(!n[s])t-=1,s+=1}const m=t-1+b;if(m>=34||m<=-7||b>0){if(t>34)return l.push("0"),b>0?l.push(`E+${b}`):b<0&&l.push(`E${b}`),l.join("");l.push(`${n[s++]}`),t-=1,t&&l.push(".");for(let e=0;e<t;e++)l.push(`${n[s++]}`);l.push("E"),m>0?l.push(`+${m}`):l.push(`${m}`)}else if(b>=0)for(let w=0;w<t;w++)l.push(`${n[s++]}`);else{let e=t+b;if(e>0)for(let t=0;t<e;t++)l.push(`${n[s++]}`);else l.push("0");l.push(".");while(e++<0)l.push("0");for(let r=0;r<t-Math.max(e-1,0);r++)l.push(`${n[s++]}`)}return l.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(e){return He.fromString(e.$numberDecimal)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Decimal128("${this.toString()}")`}}class qe extends re{get _bsontype(){return"Double"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=+e}valueOf(){return this.value}toJSON(){return this.value}toString(e){return this.value.toString(e)}toExtendedJSON(e){return e&&(e.legacy||e.relaxed&&isFinite(this.value))?this.value:Object.is(Math.sign(this.value),-0)?{$numberDouble:"-0.0"}:{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(e,t){const n=parseFloat(e.$numberDouble);return t&&t.relaxed?n:new qe(n)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const e=this.toExtendedJSON();return`new Double(${e.$numberDouble})`}}class Ce extends re{get _bsontype(){return"Int32"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=0|+e}valueOf(){return this.value}toString(e){return this.value.toString(e)}toJSON(){return this.value}toExtendedJSON(e){return e&&(e.relaxed||e.legacy)?this.value:{$numberInt:this.value.toString()}}static fromExtendedJSON(e,t){return t&&t.relaxed?parseInt(e.$numberInt,10):new Ce(e.$numberInt)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Int32(${this.valueOf()})`}}class Ze extends re{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new Ze}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return"new MaxKey()"}}class Ye extends re{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new Ye}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return"new MinKey()"}}const Pe=new RegExp("^[0-9a-fA-F]{24}$");let Ke=null;const We=Symbol("id");class Ge extends re{get _bsontype(){return"ObjectId"}constructor(e){let t;if(super(),"object"===typeof e&&e&&"id"in e){if("string"!==typeof e.id&&!ArrayBuffer.isView(e.id))throw new H("Argument passed in must have an id that is of type string or Buffer");t="toHexString"in e&&"function"===typeof e.toHexString?te.fromHex(e.toHexString()):e.id}else t=e;if(null==t||"number"===typeof t)this[We]=Ge.generate("number"===typeof t?t:void 0);else if(ArrayBuffer.isView(t)&&12===t.byteLength)this[We]=te.toLocalBufferType(t);else{if("string"!==typeof t)throw new H("Argument passed in does not match the accepted types");if(24!==t.length||!Pe.test(t))throw new H("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");this[We]=te.fromHex(t)}Ge.cacheHexString&&(this.__id=te.toHex(this.id))}get id(){return this[We]}set id(e){this[We]=e,Ge.cacheHexString&&(this.__id=te.toHex(e))}toHexString(){if(Ge.cacheHexString&&this.__id)return this.__id;const e=te.toHex(this.id);return Ge.cacheHexString&&!this.__id&&(this.__id=e),e}static getInc(){return Ge.index=(Ge.index+1)%16777215}static generate(e){"number"!==typeof e&&(e=Math.floor(Date.now()/1e3));const t=Ge.getInc(),n=te.allocate(12);return ne.fromUint8Array(n).setUint32(0,e,!1),null===Ke&&(Ke=te.randomBytes(5)),n[4]=Ke[0],n[5]=Ke[1],n[6]=Ke[2],n[7]=Ke[3],n[8]=Ke[4],n[11]=255&t,n[10]=t>>8&255,n[9]=t>>16&255,n}toString(e){return"base64"===e?te.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}static is(e){return null!=e&&"object"===typeof e&&"_bsontype"in e&&"ObjectId"===e._bsontype}equals(e){if(void 0===e||null===e)return!1;if(Ge.is(e))return this[We][11]===e[We][11]&&te.equals(this[We],e[We]);if("string"===typeof e)return e.toLowerCase()===this.toHexString();if("object"===typeof e&&"function"===typeof e.toHexString){const t=e.toHexString(),n=this.toHexString();return"string"===typeof t&&t.toLowerCase()===n}return!1}getTimestamp(){const e=new Date,t=ne.fromUint8Array(this.id).getUint32(0,!1);return e.setTime(1e3*Math.floor(t)),e}static createPk(){return new Ge}static createFromTime(e){const t=te.fromNumberArray([0,0,0,0,0,0,0,0,0,0,0,0]);return ne.fromUint8Array(t).setUint32(0,e,!1),new Ge(t)}static createFromHexString(e){if(24!==e?.length)throw new H("hex string must be 24 characters");return new Ge(te.fromHex(e))}static createFromBase64(e){if(16!==e?.length)throw new H("base64 string must be 16 characters");return new Ge(te.fromBase64(e))}static isValid(e){if(null==e)return!1;try{return new Ge(e),!0}catch{return!1}}toExtendedJSON(){return this.toHexString?{$oid:this.toHexString()}:{$oid:this.toString("hex")}}static fromExtendedJSON(e){return new Ge(e.$oid)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new ObjectId("${this.toHexString()}")`}}function Xe(e,t,n){let r=5;if(Array.isArray(e))for(let i=0;i<e.length;i++)r+=Qe(i.toString(),e[i],t,!0,n);else{"function"===typeof e?.toBSON&&(e=e.toBSON());for(const i of Object.keys(e))r+=Qe(i,e[i],t,!1,n)}return r}function Qe(e,t,n=!1,r=!1,i=!1){switch("function"===typeof t?.toBSON&&(t=t.toBSON()),typeof t){case"string":return 1+te.utf8ByteLength(e)+1+4+te.utf8ByteLength(t)+1;case"number":return Math.floor(t)===t&&t>=m&&t<=b&&t>=d&&t<=g?(null!=e?te.utf8ByteLength(e)+1:0)+5:(null!=e?te.utf8ByteLength(e)+1:0)+9;case"undefined":return r||!i?(null!=e?te.utf8ByteLength(e)+1:0)+1:0;case"boolean":return(null!=e?te.utf8ByteLength(e)+1:0)+2;case"object":if(null!=t&&"string"===typeof t._bsontype&&t[Symbol.for("@@mdb.bson.version")]!==h)throw new q;if(null==t||"MinKey"===t._bsontype||"MaxKey"===t._bsontype)return(null!=e?te.utf8ByteLength(e)+1:0)+1;if("ObjectId"===t._bsontype)return(null!=e?te.utf8ByteLength(e)+1:0)+13;if(t instanceof Date||c(t))return(null!=e?te.utf8ByteLength(e)+1:0)+9;if(ArrayBuffer.isView(t)||t instanceof ArrayBuffer||u(t))return(null!=e?te.utf8ByteLength(e)+1:0)+6+t.byteLength;if("Long"===t._bsontype||"Double"===t._bsontype||"Timestamp"===t._bsontype)return(null!=e?te.utf8ByteLength(e)+1:0)+9;if("Decimal128"===t._bsontype)return(null!=e?te.utf8ByteLength(e)+1:0)+17;if("Code"===t._bsontype)return null!=t.scope&&Object.keys(t.scope).length>0?(null!=e?te.utf8ByteLength(e)+1:0)+1+4+4+te.utf8ByteLength(t.code.toString())+1+Xe(t.scope,n,i):(null!=e?te.utf8ByteLength(e)+1:0)+1+4+te.utf8ByteLength(t.code.toString())+1;if("Binary"===t._bsontype){const n=t;return n.sub_type===ie.SUBTYPE_BYTE_ARRAY?(null!=e?te.utf8ByteLength(e)+1:0)+(n.position+1+4+1+4):(null!=e?te.utf8ByteLength(e)+1:0)+(n.position+1+4+1)}if("Symbol"===t._bsontype)return(null!=e?te.utf8ByteLength(e)+1:0)+te.utf8ByteLength(t.value)+4+1+1;if("DBRef"===t._bsontype){const r=Object.assign({$ref:t.collection,$id:t.oid},t.fields);return null!=t.db&&(r["$db"]=t.db),(null!=e?te.utf8ByteLength(e)+1:0)+1+Xe(r,n,i)}return t instanceof RegExp||l(t)?(null!=e?te.utf8ByteLength(e)+1:0)+1+te.utf8ByteLength(t.source)+1+(t.global?1:0)+(t.ignoreCase?1:0)+(t.multiline?1:0)+1:"BSONRegExp"===t._bsontype?(null!=e?te.utf8ByteLength(e)+1:0)+1+te.utf8ByteLength(t.pattern)+1+te.utf8ByteLength(t.options)+1:(null!=e?te.utf8ByteLength(e)+1:0)+Xe(t,n,i)+1;case"function":if(n)return(null!=e?te.utf8ByteLength(e)+1:0)+1+4+te.utf8ByteLength(t.toString())+1}return 0}function et(e){return e.split("").sort().join("")}Ge.index=Math.floor(16777215*Math.random());class tt extends re{get _bsontype(){return"BSONRegExp"}constructor(e,t){if(super(),this.pattern=e,this.options=et(t??""),-1!==this.pattern.indexOf("\0"))throw new H(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);if(-1!==this.options.indexOf("\0"))throw new H(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);for(let n=0;n<this.options.length;n++)if("i"!==this.options[n]&&"m"!==this.options[n]&&"x"!==this.options[n]&&"l"!==this.options[n]&&"s"!==this.options[n]&&"u"!==this.options[n])throw new H(`The regular expression option [${this.options[n]}] is not supported`)}static parseOptions(e){return e?e.split("").sort().join(""):""}toExtendedJSON(e){return e=e||{},e.legacy?{$regex:this.pattern,$options:this.options}:{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(e){if("$regex"in e){if("string"===typeof e.$regex)return new tt(e.$regex,tt.parseOptions(e.$options));if("BSONRegExp"===e.$regex._bsontype)return e}if("$regularExpression"in e)return new tt(e.$regularExpression.pattern,tt.parseOptions(e.$regularExpression.options));throw new H(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(e)}`)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`}}class nt extends re{get _bsontype(){return"BSONSymbol"}constructor(e){super(),this.value=e}valueOf(){return this.value}toString(){return this.value}inspect(){return`new BSONSymbol(${JSON.stringify(this.value)})`}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(e){return new nt(e.$symbol)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}}const rt=Ne;class it extends rt{get _bsontype(){return"Timestamp"}constructor(e){if(null==e)super(0,0,!0);else if("bigint"===typeof e)super(e,!0);else if(Ne.isLong(e))super(e.low,e.high,!0);else{if("object"!==typeof e||!("t"in e)||!("i"in e))throw new H("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");{if("number"!==typeof e.t&&("object"!==typeof e.t||"Int32"!==e.t._bsontype))throw new H("Timestamp constructed from { t, i } must provide t as a number");if("number"!==typeof e.i&&("object"!==typeof e.i||"Int32"!==e.i._bsontype))throw new H("Timestamp constructed from { t, i } must provide i as a number");const t=Number(e.t),n=Number(e.i);if(t<0||Number.isNaN(t))throw new H("Timestamp constructed from { t, i } must provide a positive t");if(n<0||Number.isNaN(n))throw new H("Timestamp constructed from { t, i } must provide a positive i");if(t>4294967295)throw new H("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");if(n>4294967295)throw new H("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");super(n,t,!0)}}}toJSON(){return{$timestamp:this.toString()}}static fromInt(e){return new it(Ne.fromInt(e,!0))}static fromNumber(e){return new it(Ne.fromNumber(e,!0))}static fromBits(e,t){return new it({i:e,t:t})}static fromString(e,t){return new it(Ne.fromString(e,!0,t))}toExtendedJSON(){return{$timestamp:{t:this.high>>>0,i:this.low>>>0}}}static fromExtendedJSON(e){const t=Ne.isLong(e.$timestamp.i)?e.$timestamp.i.getLowBitsUnsigned():e.$timestamp.i,n=Ne.isLong(e.$timestamp.t)?e.$timestamp.t.getLowBitsUnsigned():e.$timestamp.t;return new it({t:n,i:t})}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`}}it.MAX_VALUE=Ne.MAX_UNSIGNED_VALUE;const ot=128,st=192,ut=224,ft=240,lt=248,at=192,ct=224,ht=240,gt=128;function dt(e,t,n){let r=0;for(let i=t;i<n;i+=1){const t=e[i];if(r){if((t&st)!==gt)return!1;r-=1}else if(t&ot)if((t&ut)===at)r=1;else if((t&ft)===ct)r=2;else{if((t&lt)!==ht)return!1;r=3}}return!r}const pt=Ne.fromNumber(b),yt=Ne.fromNumber(m);function bt(e,t,n){t=null==t?{}:t;const r=t&&t.index?t.index:0,i=e[r]|e[r+1]<<8|e[r+2]<<16|e[r+3]<<24;if(i<5)throw new H(`bson size must be >= 5, is ${i}`);if(t.allowObjectSmallerThanBufferSize&&e.length<i)throw new H(`buffer length ${e.length} must be >= bson size ${i}`);if(!t.allowObjectSmallerThanBufferSize&&e.length!==i)throw new H(`buffer length ${e.length} must === bson size ${i}`);if(i+r>e.byteLength)throw new H(`(bson size ${i} + options.index ${r} must be <= buffer length ${e.byteLength})`);if(0!==e[r+i-1])throw new H("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return wt(e,r,t,n)}const mt=/^\$ref$|^\$id$|^\$db$/;function wt(e,t,n,r=!1){const i=null==n["fieldsAsRaw"]?null:n["fieldsAsRaw"],o=null!=n["raw"]&&n["raw"],s="boolean"===typeof n["bsonRegExp"]&&n["bsonRegExp"],u=n.promoteBuffers??!1,f=n.promoteLongs??!0,l=n.promoteValues??!0,a=n.useBigInt64??!1;if(a&&!l)throw new H("Must either request bigint or Long for int64 deserialization");if(a&&!f)throw new H("Must either request bigint or Long for int64 deserialization");const c=null==n.validation?{utf8:!0}:n.validation;let h,g=!0;const d=new Set,p=c.utf8;if("boolean"===typeof p)h=p;else{g=!1;const e=Object.keys(p).map((function(e){return p[e]}));if(0===e.length)throw new H("UTF-8 validation setting cannot be empty");if("boolean"!==typeof e[0])throw new H("Invalid UTF-8 validation option, must specify boolean values");if(h=e[0],!e.every((e=>e===h)))throw new H("Invalid UTF-8 validation option - keys must be all true or all false")}if(!g)for(const w of Object.keys(p))d.add(w);const y=t;if(e.length<5)throw new H("corrupt bson message < 5 bytes long");const b=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(b<5||b>e.length)throw new H("corrupt bson message");const m=r?[]:{};let V=0;const k=!1;let q=!r&&null;const C=new DataView(e.buffer,e.byteOffset,e.byteLength);while(!k){const p=e[t++];if(0===p)break;let y=t;while(0!==e[y]&&y<e.length)y++;if(y>=e.byteLength)throw new H("Bad BSON Document: illegal CString");const b=r?V++:te.toUTF8(e,t,y);let k,Z=!0;if(Z=g||d.has(b)?h:!h,!1!==q&&"$"===b[0]&&(q=mt.test(b)),t=y+1,p===S){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new H("bad string length in bson");k=St(e,t,t+n-1,Z),t+=n}else if(p===_){const n=te.allocate(12);n.set(e.subarray(t,t+12)),k=new Ge(n),t+=12}else if(p===A&&!1===l)k=new Ce(e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24);else if(p===A)k=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;else if(p===w&&!1===l)k=new qe(C.getFloat64(t,!0)),t+=8;else if(p===w)k=C.getFloat64(t,!0),t+=8;else if(p===E){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;k=new Date(new Ne(n,r).toNumber())}else if(p===$){if(0!==e[t]&&1!==e[t])throw new H("illegal boolean type value");k=1===e[t++]}else if(p===B){const r=t,i=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24;if(i<=0||i>e.length-t)throw new H("bad embedded document length in bson");if(o)k=e.slice(t,t+i);else{let t=n;g||(t={...n,validation:{utf8:Z}}),k=wt(e,r,t,!1)}t+=i}else if(p===N){const r=t,o=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24;let s=n;const u=t+o;if(i&&i[b]&&(s={...n,raw:!0}),g||(s={...s,validation:{utf8:Z}}),k=wt(e,r,s,!0),t+=o,0!==e[t-1])throw new H("invalid array terminator byte");if(t!==u)throw new H("corrupted array bson")}else if(p===x)k=void 0;else if(p===U)k=null;else if(p===R){const n=ne.fromUint8Array(e.subarray(t,t+8)),r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,i=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,o=new Ne(r,i);k=a?n.getBigInt64(0,!0):f&&!0===l&&o.lessThanOrEqual(pt)&&o.greaterThanOrEqual(yt)?o.toNumber():o}else if(p===F){const n=te.allocate(16);n.set(e.subarray(t,t+16),0),t+=16,k=new He(n)}else if(p===O){let n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;const r=n,i=e[t++];if(n<0)throw new H("Negative binary type element size found");if(n>e.byteLength)throw new H("Binary type size larger than document size");if(null!=e["slice"]){if(i===ie.SUBTYPE_BYTE_ARRAY){if(n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,n<0)throw new H("Negative binary type element size found for subtype 0x02");if(n>r-4)throw new H("Binary type with subtype 0x02 contains too long binary size");if(n<r-4)throw new H("Binary type with subtype 0x02 contains too short binary size")}u&&l?k=te.toLocalBufferType(e.slice(t,t+n)):(k=new ie(e.slice(t,t+n),i),i===z&&fe.isValid(k)&&(k=k.toUUID()))}else{const o=te.allocate(n);if(i===ie.SUBTYPE_BYTE_ARRAY){if(n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,n<0)throw new H("Negative binary type element size found for subtype 0x02");if(n>r-4)throw new H("Binary type with subtype 0x02 contains too long binary size");if(n<r-4)throw new H("Binary type with subtype 0x02 contains too short binary size")}for(y=0;y<n;y++)o[y]=e[t+y];u&&l?k=o:(k=new ie(e.slice(t,t+n),i),i===z&&fe.isValid(k)&&(k=k.toUUID()))}t+=n}else if(p===v&&!1===s){y=t;while(0!==e[y]&&y<e.length)y++;if(y>=e.length)throw new H("Bad BSON Document: illegal CString");const n=te.toUTF8(e,t,y);t=y+1,y=t;while(0!==e[y]&&y<e.length)y++;if(y>=e.length)throw new H("Bad BSON Document: illegal CString");const r=te.toUTF8(e,t,y);t=y+1;const i=new Array(r.length);for(y=0;y<r.length;y++)switch(r[y]){case"m":i[y]="m";break;case"s":i[y]="g";break;case"i":i[y]="i";break}k=new RegExp(n,i.join(""))}else if(p===v&&!0===s){y=t;while(0!==e[y]&&y<e.length)y++;if(y>=e.length)throw new H("Bad BSON Document: illegal CString");const n=te.toUTF8(e,t,y);t=y+1,y=t;while(0!==e[y]&&y<e.length)y++;if(y>=e.length)throw new H("Bad BSON Document: illegal CString");const r=te.toUTF8(e,t,y);t=y+1,k=new tt(n,r)}else if(p===L){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new H("bad string length in bson");const r=St(e,t,t+n-1,Z);k=l?r:new nt(r),t+=n}else if(p===D){const n=e[t++]+256*e[t++]+65536*e[t++]+e[t++]*(1<<24),r=e[t++]+256*e[t++]+65536*e[t++]+e[t++]*(1<<24);k=new it({i:n,t:r})}else if(p===M)k=new Ye;else if(p===J)k=new Ze;else if(p===T){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new H("bad string length in bson");const r=St(e,t,t+n-1,Z);k=new le(r),t+=n}else if(p===j){const r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(r<13)throw new H("code_w_scope total size shorter minimum expected length");const i=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(i<=0||i>e.length-t||0!==e[t+i-1])throw new H("bad string length in bson");const o=St(e,t,t+i-1,Z);t+=i;const s=t,u=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24,f=wt(e,s,n,!1);if(t+=u,r<8+u+i)throw new H("code_w_scope total size is too short, truncating scope");if(r>8+u+i)throw new H("code_w_scope total size is too long, clips outer document");k=new le(o,f)}else{if(p!==I)throw new H(`Detected unknown BSON type ${p.toString(16)} for fieldname "${b}"`);{const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new H("bad string length in bson");if(null!=c&&c.utf8&&!dt(e,t,t+n-1))throw new H("Invalid UTF-8 string in BSON document");const r=te.toUTF8(e,t,t+n-1);t+=n;const i=te.allocate(12);i.set(e.subarray(t,t+12),0);const o=new Ge(i);t+=12,k=new ce(r,o)}}"__proto__"===b?Object.defineProperty(m,b,{value:k,writable:!0,enumerable:!0,configurable:!0}):m[b]=k}if(b!==t-y){if(r)throw new H("corrupt array bson");throw new H("corrupt object bson")}if(!q)return m;if(ae(m)){const e=Object.assign({},m);return delete e.$ref,delete e.$id,delete e.$db,new ce(m.$ref,m.$id,m.$db,e)}return m}function St(e,t,n,r){const i=te.toUTF8(e,t,n);if(r)for(let o=0;o<i.length;o++)if(65533===i.charCodeAt(o)){if(!dt(e,t,n))throw new H("Invalid UTF-8 string in BSON document");break}return i}const Bt=/\x00/,Nt=new Set(["$db","$ref","$id","$clusterTime"]);function Ot(e,t,n,r){e[r++]=S;const i=te.encodeUTF8Into(e,t,r);r=r+i+1,e[r-1]=0;const o=te.encodeUTF8Into(e,n,r+4);return e[r+3]=o+1>>24&255,e[r+2]=o+1>>16&255,e[r+1]=o+1>>8&255,e[r]=o+1&255,r=r+4+o,e[r++]=0,r}const xt=new DataView(new ArrayBuffer(8),0,8),_t=new Uint8Array(xt.buffer,0,4),$t=new Uint8Array(xt.buffer,0,8);function Et(e,t,n,r){const i=Object.is(n,-0),o=!i&&Number.isSafeInteger(n)&&n<=g&&n>=d?A:w;o===A?xt.setInt32(0,n,!0):xt.setFloat64(0,n,!0);const s=o===A?_t:$t;e[r++]=o;const u=te.encodeUTF8Into(e,t,r);return r+=u,e[r++]=0,e.set(s,r),r+=s.byteLength,r}function Ut(e,t,n,r){e[r++]=R;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,xt.setBigInt64(0,n,!0),e.set($t,r),r+=$t.byteLength,r}function vt(e,t,n,r){e[r++]=U;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,r}function It(e,t,n,r){e[r++]=$;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,e[r++]=n?1:0,r}function Tt(e,t,n,r){e[r++]=E;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=Ne.fromNumber(n.getTime()),s=o.getLowBits(),u=o.getHighBits();return e[r++]=255&s,e[r++]=s>>8&255,e[r++]=s>>16&255,e[r++]=s>>24&255,e[r++]=255&u,e[r++]=u>>8&255,e[r++]=u>>16&255,e[r++]=u>>24&255,r}function Lt(e,t,n,r){e[r++]=v;const i=te.encodeUTF8Into(e,t,r);if(r+=i,e[r++]=0,n.source&&null!=n.source.match(Bt))throw new H("value "+n.source+" must not contain null bytes");return r+=te.encodeUTF8Into(e,n.source,r),e[r++]=0,n.ignoreCase&&(e[r++]=105),n.global&&(e[r++]=115),n.multiline&&(e[r++]=109),e[r++]=0,r}function jt(e,t,n,r){e[r++]=v;const i=te.encodeUTF8Into(e,t,r);if(r+=i,e[r++]=0,null!=n.pattern.match(Bt))throw new H("pattern "+n.pattern+" must not contain null bytes");r+=te.encodeUTF8Into(e,n.pattern,r),e[r++]=0;const o=n.options.split("").sort().join("");return r+=te.encodeUTF8Into(e,o,r),e[r++]=0,r}function At(e,t,n,r){null===n?e[r++]=U:"MinKey"===n._bsontype?e[r++]=M:e[r++]=J;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,r}function Dt(e,t,n,r){e[r++]=_;const i=te.encodeUTF8Into(e,t,r);if(r+=i,e[r++]=0,!f(n.id))throw new H("object ["+JSON.stringify(n)+"] is not a valid ObjectId");return e.set(n.id.subarray(0,12),r),r+12}function Rt(e,t,n,r){e[r++]=O;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=n.length;return e[r++]=255&o,e[r++]=o>>8&255,e[r++]=o>>16&255,e[r++]=o>>24&255,e[r++]=V,e.set(n,r),r+=o,r}function Ft(e,t,n,r,i,o,s,u,f){if(f.has(n))throw new H("Cannot convert circular structure to BSON");f.add(n),e[r++]=Array.isArray(n)?N:B;const l=te.encodeUTF8Into(e,t,r);r+=l,e[r++]=0;const a=Yt(e,n,i,r,o+1,s,u,f);return f.delete(n),a}function Mt(e,t,n,r){e[r++]=F;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,e.set(n.bytes.subarray(0,16),r),r+16}function Jt(e,t,n,r){e[r++]="Long"===n._bsontype?R:D;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=n.getLowBits(),s=n.getHighBits();return e[r++]=255&o,e[r++]=o>>8&255,e[r++]=o>>16&255,e[r++]=o>>24&255,e[r++]=255&s,e[r++]=s>>8&255,e[r++]=s>>16&255,e[r++]=s>>24&255,r}function Vt(e,t,n,r){n=n.valueOf(),e[r++]=A;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,e[r++]=255&n,e[r++]=n>>8&255,e[r++]=n>>16&255,e[r++]=n>>24&255,r}function zt(e,t,n,r){e[r++]=w;const i=te.encodeUTF8Into(e,t,r);return r+=i,e[r++]=0,xt.setFloat64(0,n.value,!0),e.set($t,r),r+=8,r}function kt(e,t,n,r){e[r++]=T;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=n.toString(),s=te.encodeUTF8Into(e,o,r+4)+1;return e[r]=255&s,e[r+1]=s>>8&255,e[r+2]=s>>16&255,e[r+3]=s>>24&255,r=r+4+s-1,e[r++]=0,r}function Ht(e,t,n,r,i=!1,o=0,s=!1,u=!0,f){if(n.scope&&"object"===typeof n.scope){e[r++]=j;const l=te.encodeUTF8Into(e,t,r);r+=l,e[r++]=0;let a=r;const c=n.code;r+=4;const h=te.encodeUTF8Into(e,c,r+4)+1;e[r]=255&h,e[r+1]=h>>8&255,e[r+2]=h>>16&255,e[r+3]=h>>24&255,e[r+4+h-1]=0,r=r+h+4;const g=Yt(e,n.scope,i,r,o+1,s,u,f);r=g-1;const d=g-a;e[a++]=255&d,e[a++]=d>>8&255,e[a++]=d>>16&255,e[a++]=d>>24&255,e[r++]=0}else{e[r++]=T;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=n.code.toString(),s=te.encodeUTF8Into(e,o,r+4)+1;e[r]=255&s,e[r+1]=s>>8&255,e[r+2]=s>>16&255,e[r+3]=s>>24&255,r=r+4+s-1,e[r++]=0}return r}function qt(e,t,n,r){e[r++]=O;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=n.buffer;let s=n.position;return n.sub_type===ie.SUBTYPE_BYTE_ARRAY&&(s+=4),e[r++]=255&s,e[r++]=s>>8&255,e[r++]=s>>16&255,e[r++]=s>>24&255,e[r++]=n.sub_type,n.sub_type===ie.SUBTYPE_BYTE_ARRAY&&(s-=4,e[r++]=255&s,e[r++]=s>>8&255,e[r++]=s>>16&255,e[r++]=s>>24&255),e.set(o,r),r+=n.position,r}function Ct(e,t,n,r){e[r++]=L;const i=te.encodeUTF8Into(e,t,r);r+=i,e[r++]=0;const o=te.encodeUTF8Into(e,n.value,r+4)+1;return e[r]=255&o,e[r+1]=o>>8&255,e[r+2]=o>>16&255,e[r+3]=o>>24&255,r=r+4+o-1,e[r++]=0,r}function Zt(e,t,n,r,i,o,s){e[r++]=B;const u=te.encodeUTF8Into(e,t,r);r+=u,e[r++]=0;let f=r,l={$ref:n.collection||n.namespace,$id:n.oid};null!=n.db&&(l.$db=n.db),l=Object.assign(l,n.fields);const a=Yt(e,l,!1,r,i+1,o,!0,s),c=a-f;return e[f++]=255&c,e[f++]=c>>8&255,e[f++]=c>>16&255,e[f++]=c>>24&255,a}function Yt(e,t,n,r,i,o,s,g){if(null==g){if(null==t)return e[0]=5,e[1]=0,e[2]=0,e[3]=0,e[4]=0,5;if(Array.isArray(t))throw new H("serialize does not support an array as the root input");if("object"!==typeof t)throw new H("serialize does not support non-object as the root input");if("_bsontype"in t&&"string"===typeof t._bsontype)throw new H("BSON types cannot be serialized as a document");if(c(t)||l(t)||f(t)||u(t))throw new H("date, regexp, typedarray, and arraybuffer cannot be BSON documents");g=new Set}g.add(t);let d=r+4;if(Array.isArray(t))for(let u=0;u<t.length;u++){const r=`${u}`;let a=t[u];if("function"===typeof a?.toBSON&&(a=a.toBSON()),"string"===typeof a)d=Ot(e,r,a,d);else if("number"===typeof a)d=Et(e,r,a,d);else if("bigint"===typeof a)d=Ut(e,r,a,d);else if("boolean"===typeof a)d=It(e,r,a,d);else if(a instanceof Date||c(a))d=Tt(e,r,a,d);else if(void 0===a)d=vt(e,r,a,d);else if(null===a)d=vt(e,r,a,d);else if(f(a))d=Rt(e,r,a,d);else if(a instanceof RegExp||l(a))d=Lt(e,r,a,d);else if("object"===typeof a&&null==a._bsontype)d=Ft(e,r,a,d,n,i,o,s,g);else{if("object"===typeof a&&a[Symbol.for("@@mdb.bson.version")]!==h)throw new q;if("ObjectId"===a._bsontype)d=Dt(e,r,a,d);else if("Decimal128"===a._bsontype)d=Mt(e,r,a,d);else if("Long"===a._bsontype||"Timestamp"===a._bsontype)d=Jt(e,r,a,d);else if("Double"===a._bsontype)d=zt(e,r,a,d);else if("function"===typeof a&&o)d=kt(e,r,a,d);else if("Code"===a._bsontype)d=Ht(e,r,a,d,n,i,o,s,g);else if("Binary"===a._bsontype)d=qt(e,r,a,d);else if("BSONSymbol"===a._bsontype)d=Ct(e,r,a,d);else if("DBRef"===a._bsontype)d=Zt(e,r,a,d,i,o,g);else if("BSONRegExp"===a._bsontype)d=jt(e,r,a,d);else if("Int32"===a._bsontype)d=Vt(e,r,a,d);else if("MinKey"===a._bsontype||"MaxKey"===a._bsontype)d=At(e,r,a,d);else if("undefined"!==typeof a._bsontype)throw new H(`Unrecognized or invalid _bsontype: ${String(a._bsontype)}`)}}else if(t instanceof Map||a(t)){const r=t.entries();let u=!1;while(!u){const t=r.next();if(u=!!t.done,u)continue;const a=t.value[0];let p=t.value[1];"function"===typeof p?.toBSON&&(p=p.toBSON());const y=typeof p;if("string"===typeof a&&!Nt.has(a)){if(null!=a.match(Bt))throw new H("key "+a+" must not contain null bytes");if(n){if("$"===a[0])throw new H("key "+a+" must not start with '$'");if(~a.indexOf("."))throw new H("key "+a+" must not contain '.'")}}if("string"===y)d=Ot(e,a,p,d);else if("number"===y)d=Et(e,a,p,d);else if("bigint"===y)d=Ut(e,a,p,d);else if("boolean"===y)d=It(e,a,p,d);else if(p instanceof Date||c(p))d=Tt(e,a,p,d);else if(null===p||void 0===p&&!1===s)d=vt(e,a,p,d);else if(f(p))d=Rt(e,a,p,d);else if(p instanceof RegExp||l(p))d=Lt(e,a,p,d);else if("object"===y&&null==p._bsontype)d=Ft(e,a,p,d,n,i,o,s,g);else{if("object"===typeof p&&p[Symbol.for("@@mdb.bson.version")]!==h)throw new q;if("ObjectId"===p._bsontype)d=Dt(e,a,p,d);else if("object"===y&&"Decimal128"===p._bsontype)d=Mt(e,a,p,d);else if("Long"===p._bsontype||"Timestamp"===p._bsontype)d=Jt(e,a,p,d);else if("Double"===p._bsontype)d=zt(e,a,p,d);else if("Code"===p._bsontype)d=Ht(e,a,p,d,n,i,o,s,g);else if("function"===typeof p&&o)d=kt(e,a,p,d);else if("Binary"===p._bsontype)d=qt(e,a,p,d);else if("BSONSymbol"===p._bsontype)d=Ct(e,a,p,d);else if("DBRef"===p._bsontype)d=Zt(e,a,p,d,i,o,g);else if("BSONRegExp"===p._bsontype)d=jt(e,a,p,d);else if("Int32"===p._bsontype)d=Vt(e,a,p,d);else if("MinKey"===p._bsontype||"MaxKey"===p._bsontype)d=At(e,a,p,d);else if("undefined"!==typeof p._bsontype)throw new H(`Unrecognized or invalid _bsontype: ${String(p._bsontype)}`)}}}else{if("function"===typeof t?.toBSON&&(t=t.toBSON(),null!=t&&"object"!==typeof t))throw new H("toBSON function did not return an object");for(const r of Object.keys(t)){let u=t[r];"function"===typeof u?.toBSON&&(u=u.toBSON());const a=typeof u;if("string"===typeof r&&!Nt.has(r)){if(null!=r.match(Bt))throw new H("key "+r+" must not contain null bytes");if(n){if("$"===r[0])throw new H("key "+r+" must not start with '$'");if(~r.indexOf("."))throw new H("key "+r+" must not contain '.'")}}if("string"===a)d=Ot(e,r,u,d);else if("number"===a)d=Et(e,r,u,d);else if("bigint"===a)d=Ut(e,r,u,d);else if("boolean"===a)d=It(e,r,u,d);else if(u instanceof Date||c(u))d=Tt(e,r,u,d);else if(void 0===u)!1===s&&(d=vt(e,r,u,d));else if(null===u)d=vt(e,r,u,d);else if(f(u))d=Rt(e,r,u,d);else if(u instanceof RegExp||l(u))d=Lt(e,r,u,d);else if("object"===a&&null==u._bsontype)d=Ft(e,r,u,d,n,i,o,s,g);else{if("object"===typeof u&&u[Symbol.for("@@mdb.bson.version")]!==h)throw new q;if("ObjectId"===u._bsontype)d=Dt(e,r,u,d);else if("object"===a&&"Decimal128"===u._bsontype)d=Mt(e,r,u,d);else if("Long"===u._bsontype||"Timestamp"===u._bsontype)d=Jt(e,r,u,d);else if("Double"===u._bsontype)d=zt(e,r,u,d);else if("Code"===u._bsontype)d=Ht(e,r,u,d,n,i,o,s,g);else if("function"===typeof u&&o)d=kt(e,r,u,d);else if("Binary"===u._bsontype)d=qt(e,r,u,d);else if("BSONSymbol"===u._bsontype)d=Ct(e,r,u,d);else if("DBRef"===u._bsontype)d=Zt(e,r,u,d,i,o,g);else if("BSONRegExp"===u._bsontype)d=jt(e,r,u,d);else if("Int32"===u._bsontype)d=Vt(e,r,u,d);else if("MinKey"===u._bsontype||"MaxKey"===u._bsontype)d=At(e,r,u,d);else if("undefined"!==typeof u._bsontype)throw new H(`Unrecognized or invalid _bsontype: ${String(u._bsontype)}`)}}}g.delete(t),e[d++]=0;const p=d-r;return e[r++]=255&p,e[r++]=p>>8&255,e[r++]=p>>16&255,e[r++]=p>>24&255,d}function Pt(e){return null!=e&&"object"===typeof e&&"_bsontype"in e&&"string"===typeof e._bsontype}const Kt={$oid:Ge,$binary:ie,$uuid:ie,$symbol:nt,$numberInt:Ce,$numberDecimal:He,$numberDouble:qe,$numberLong:Ne,$minKey:Ye,$maxKey:Ze,$regex:tt,$regularExpression:tt,$timestamp:it};function Wt(e,t={}){if("number"===typeof e){const n=e<=g&&e>=d,r=e<=p&&e>=y;if(t.relaxed||t.legacy)return e;if(Number.isInteger(e)&&!Object.is(e,-0)){if(n)return new Ce(e);if(r)return t.useBigInt64?BigInt(e):Ne.fromNumber(e)}return new qe(e)}if(null==e||"object"!==typeof e)return e;if(e.$undefined)return null;const n=Object.keys(e).filter((t=>t.startsWith("$")&&null!=e[t]));for(let r=0;r<n.length;r++){const i=Kt[n[r]];if(i)return i.fromExtendedJSON(e,t)}if(null!=e.$date){const n=e.$date,r=new Date;if(t.legacy)if("number"===typeof n)r.setTime(n);else if("string"===typeof n)r.setTime(Date.parse(n));else{if("bigint"!==typeof n)throw new C("Unrecognized type for EJSON date: "+typeof n);r.setTime(Number(n))}else if("string"===typeof n)r.setTime(Date.parse(n));else if(Ne.isLong(n))r.setTime(n.toNumber());else if("number"===typeof n&&t.relaxed)r.setTime(n);else{if("bigint"!==typeof n)throw new C("Unrecognized type for EJSON date: "+typeof n);r.setTime(Number(n))}return r}if(null!=e.$code){const t=Object.assign({},e);return e.$scope&&(t.$scope=Wt(e.$scope)),le.fromExtendedJSON(e)}if(ae(e)||e.$dbPointer){const t=e.$ref?e:e.$dbPointer;if(t instanceof ce)return t;const n=Object.keys(t).filter((e=>e.startsWith("$")));let r=!0;if(n.forEach((e=>{-1===["$ref","$id","$db"].indexOf(e)&&(r=!1)})),r)return ce.fromExtendedJSON(t)}return e}function Gt(e,t){return e.map(((e,n)=>{t.seenObjects.push({propertyName:`index ${n}`,obj:null});try{return Qt(e,t)}finally{t.seenObjects.pop()}}))}function Xt(e){const t=e.toISOString();return 0!==e.getUTCMilliseconds()?t:t.slice(0,-5)+"Z"}function Qt(e,t){if(e instanceof Map||a(e)){const n=Object.create(null);for(const[t,r]of e){if("string"!==typeof t)throw new H("Can only serialize maps with string keys");n[t]=r}return Qt(n,t)}if(("object"===typeof e||"function"===typeof e)&&null!==e){const n=t.seenObjects.findIndex((t=>t.obj===e));if(-1!==n){const e=t.seenObjects.map((e=>e.propertyName)),r=e.slice(0,n).map((e=>`${e} -> `)).join(""),i=e[n],o=" -> "+e.slice(n+1,e.length-1).map((e=>`${e} -> `)).join(""),s=e[e.length-1],u=" ".repeat(r.length+i.length/2),f="-".repeat(o.length+(i.length+s.length)/2-1);throw new H(`Converting circular structure to EJSON:\n    ${r}${i}${o}${s}\n    ${u}\\${f}/`)}t.seenObjects[t.seenObjects.length-1].obj=e}if(Array.isArray(e))return Gt(e,t);if(void 0===e)return null;if(e instanceof Date||c(e)){const n=e.getTime(),r=n>-1&&n<2534023188e5;return t.legacy?t.relaxed&&r?{$date:e.getTime()}:{$date:Xt(e)}:t.relaxed&&r?{$date:Xt(e)}:{$date:{$numberLong:e.getTime().toString()}}}if("number"===typeof e&&(!t.relaxed||!isFinite(e))){if(Number.isInteger(e)&&!Object.is(e,-0)){if(e>=d&&e<=g)return{$numberInt:e.toString()};if(e>=y&&e<=p)return{$numberLong:e.toString()}}return{$numberDouble:Object.is(e,-0)?"-0.0":e.toString()}}if("bigint"===typeof e)return t.relaxed?Number(BigInt.asIntN(64,e)):{$numberLong:BigInt.asIntN(64,e).toString()};if(e instanceof RegExp||l(e)){let n=e.flags;if(void 0===n){const t=e.toString().match(/[gimuy]*$/);t&&(n=t[0])}const r=new tt(e.source,n);return r.toExtendedJSON(t)}return null!=e&&"object"===typeof e?tn(e,t):e}const en={Binary:e=>new ie(e.value(),e.sub_type),Code:e=>new le(e.code,e.scope),DBRef:e=>new ce(e.collection||e.namespace,e.oid,e.db,e.fields),Decimal128:e=>new He(e.bytes),Double:e=>new qe(e.value),Int32:e=>new Ce(e.value),Long:e=>Ne.fromBits(null!=e.low?e.low:e.low_,null!=e.low?e.high:e.high_,null!=e.low?e.unsigned:e.unsigned_),MaxKey:()=>new Ze,MinKey:()=>new Ye,ObjectId:e=>new Ge(e),BSONRegExp:e=>new tt(e.pattern,e.options),BSONSymbol:e=>new nt(e.value),Timestamp:e=>it.fromBits(e.low,e.high)};function tn(e,t){if(null==e||"object"!==typeof e)throw new H("not an object instance");const n=e._bsontype;if("undefined"===typeof n){const n={};for(const r of Object.keys(e)){t.seenObjects.push({propertyName:r,obj:null});try{const i=Qt(e[r],t);"__proto__"===r?Object.defineProperty(n,r,{value:i,writable:!0,enumerable:!0,configurable:!0}):n[r]=i}finally{t.seenObjects.pop()}}return n}if(null!=e&&"object"===typeof e&&"string"===typeof e._bsontype&&e[Symbol.for("@@mdb.bson.version")]!==h)throw new q;if(Pt(e)){let r=e;if("function"!==typeof r.toExtendedJSON){const t=en[e._bsontype];if(!t)throw new H("Unrecognized or invalid _bsontype: "+e._bsontype);r=t(r)}return"Code"===n&&r.scope?r=new le(r.code,Qt(r.scope,t)):"DBRef"===n&&r.oid&&(r=new ce(Qt(r.collection,t),Qt(r.oid,t),Qt(r.db,t),Qt(r.fields,t))),r.toExtendedJSON(t)}throw new H("_bsontype must be a string, but was: "+typeof n)}function nn(e,t){const n={useBigInt64:t?.useBigInt64??!1,relaxed:t?.relaxed??!0,legacy:t?.legacy??!1};return JSON.parse(e,((e,t)=>{if(-1!==e.indexOf("\0"))throw new H(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(e)}`);return Wt(t,n)}))}function rn(e,t,n,r){null!=n&&"object"===typeof n&&(r=n,n=0),null==t||"object"!==typeof t||Array.isArray(t)||(r=t,t=void 0,n=0);const i=Object.assign({relaxed:!0,legacy:!1},r,{seenObjects:[{propertyName:"(root)",obj:null}]}),o=Qt(e,i);return JSON.stringify(o,t,n)}function on(e,t){return t=t||{},JSON.parse(rn(e,t))}function sn(e,t){return t=t||{},nn(JSON.stringify(e),t)}const un=Object.create(null);un.parse=nn,un.stringify=rn,un.serialize=on,un.deserialize=sn,Object.freeze(un);const fn=17825792;let ln=te.allocate(fn);function an(e){ln.length<e&&(ln=te.allocate(e))}function cn(e,t={}){const n="boolean"===typeof t.checkKeys&&t.checkKeys,r="boolean"===typeof t.serializeFunctions&&t.serializeFunctions,i="boolean"!==typeof t.ignoreUndefined||t.ignoreUndefined,o="number"===typeof t.minInternalBufferSize?t.minInternalBufferSize:fn;ln.length<o&&(ln=te.allocate(o));const s=Yt(ln,e,n,0,0,r,i,null),u=te.allocate(s);return u.set(ln.subarray(0,s),0),u}function hn(e,t,n={}){const r="boolean"===typeof n.checkKeys&&n.checkKeys,i="boolean"===typeof n.serializeFunctions&&n.serializeFunctions,o="boolean"!==typeof n.ignoreUndefined||n.ignoreUndefined,s="number"===typeof n.index?n.index:0,u=Yt(ln,e,r,0,0,i,o,null);return t.set(ln.subarray(0,u),s),s+u-1}function gn(e,t={}){return bt(te.toLocalBufferType(e),t)}function dn(e,t={}){t=t||{};const n="boolean"===typeof t.serializeFunctions&&t.serializeFunctions,r="boolean"!==typeof t.ignoreUndefined||t.ignoreUndefined;return Xe(e,n,r)}function pn(e,t,n,r,i,o){const s=Object.assign({allowObjectSmallerThanBufferSize:!0,index:0},o),u=te.toLocalBufferType(e);let f=t;for(let l=0;l<n;l++){const e=u[f]|u[f+1]<<8|u[f+2]<<16|u[f+3]<<24;s.index=f,r[i+l]=bt(u,s),f+=e}return f}var o=Object.freeze({__proto__:null,BSONError:H,BSONRegExp:tt,BSONRuntimeError:C,BSONSymbol:nt,BSONType:k,BSONValue:re,BSONVersionError:q,Binary:ie,Code:le,DBRef:ce,Decimal128:He,Double:qe,EJSON:un,Int32:Ce,Long:Ne,MaxKey:Ze,MinKey:Ye,ObjectId:Ge,Timestamp:it,UUID:fe,calculateObjectSize:dn,deserialize:gn,deserializeStream:pn,serialize:cn,serializeWithBufferAndIndex:hn,setInternalBufferSize:an});r()}catch(s){r(s)}}),1)}}]);
//# sourceMappingURL=5278.50032900.js.map